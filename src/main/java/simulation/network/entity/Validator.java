package simulation.network.entity;

import simulation.network.entity.timer.TimerNotifier;
import simulation.protocol.ConsensusProgram;
import simulation.protocol.NoProgram;
import simulation.simulator.ValidatorResults;
import simulation.statistics.ConsensusStatistics;
import simulation.util.Pair;
import simulation.util.rng.RandomNumberGenerator;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Encapsulates an {@code EndpointNode} that runs a BFT protocol.
 *
 * @param <T> Message class generated by {@code Validator}.
 */
public class Validator<T extends BFTMessage> extends EndpointNode<T>
        implements ValidatorResults, TimerNotifier<ConsensusProgram<T>> {

    private final Map<Integer, Validator<T>> allNodes;
    private final int consensusLimit;
    private final TimerNotifier<Validator<T>> timerNotifier;
    private final RandomNumberGenerator rng;

    private ConsensusProgram<T> consensusProgram;
    private double previousRecordedTime;

    /**
     * @param name Name of validator.
     * @param consensusLimit Consensus count limit.
     * @param timerNotifier TimerNotifier to check time and set timers.
     * @param serviceTimeGenerator RNG for service time.
     */
    public Validator(String name, int consensusLimit, TimerNotifier<Validator<T>> timerNotifier,
            RandomNumberGenerator serviceTimeGenerator) {
        super(name);
        this.timerNotifier = timerNotifier;
        this.rng = serviceTimeGenerator;
        this.allNodes = new HashMap<>();
        this.consensusLimit = consensusLimit;
        this.consensusProgram = new NoProgram<T>();
    }

    public void setConsensusProgram(ConsensusProgram<T> consensusProgram) {
        this.consensusProgram = consensusProgram;
    }

    @Override
    public ConsensusStatistics getConsensusStatistics() {
        return consensusProgram.getStatistics();
    }

    public int getConsensusCount() {
        return consensusProgram.getConsensusCount();
    }

    @Override
    public boolean isStillRequiredToRun() {
        return getConsensusCount() < consensusLimit;
    }

    @Override
    public List<Payload<T>> initializationPayloads() {
        return consensusProgram.initializationPayloads();
    }

    /**
     * Processes payload and returns duration and list of resulting payloads.
     * Duration is generated randomly by an exponential random variable.
     * New time is set to be {@code time} + duration generated in order to set the node as occupied up to end time.
     * A consequence of this is that timeouts are only registered after the message that crosses
     * the timeout is processed.
     *
     * @param time Time payload is being processed.
     * @param payload Payload to be processed.
     * @return Returns time taken to process the payload and list of resulting payloads from processing.
     */
    @Override
    public Pair<Double, List<Payload<T>>> processPayload(double time, Payload<T> payload) {
        double duration = rng.generateRandomNumber();
        double timePassed = time - previousRecordedTime;
        previousRecordedTime = time + duration;
        consensusProgram.registerMessageProcessed(duration + timePassed);
        T message = payload.getMessage();
        List<Payload<T>> payloads = consensusProgram.processMessage(message);
        return new Pair<>(duration, payloads);
    }

    public List<Payload<T>> notifyTime(int timerCount) {
        return consensusProgram.notifyTime(timerCount);
    }

    @Override
    public void notifyAtTime(ConsensusProgram<T> program, double time, int timerCount) {
        timerNotifier.notifyAtTime(this, time, timerCount);
    }

    @Override
    public double getTime() {
        return timerNotifier.getTime();
    }
}
